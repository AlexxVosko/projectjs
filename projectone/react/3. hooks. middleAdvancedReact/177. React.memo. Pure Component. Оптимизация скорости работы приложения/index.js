// React.memo - необходим для оптимизации, мемонизирует компоненты
// сохраняет компонент/ позволяет избегать лишнего рендера -  если у него не изменились значения пропсов (касается только пропсов)


// файл App.js
// функционал рендеррнга на динамических пропсах

// Но если состоя ние меняется на точно такое же которое было?

import {memo} from 'react';
// memo нужно обенуть всю функцию
const Form = memo( ()=>{} )

// Функция memo -  компонент высшего порядка
// Сравнение пропсов идет поверхностно - вложенные пропсы будут считаться новыми

// собственная функция сравнения вложенных пропсов
function propsCompare(prevProps, nextProps){
    return prevProps.mail.name === nextProps.mail.name && prevProps.text === nextProps.text;
}

const Form2 = memo( ()=>{} , propsCompare);

//!!  С классовыми компонентами использовать PureComponent
import {PureComponent} from 'react';
class Form3 extends PureComponent {}
// внутри есть метод shouldComponentUpdate(nexrProps, nextState) который все делает без нашего участия
// можем проверять как пропсы так и состояния внутри компонента

class Form4 extends Component {

    // Дословно 
    // Должен ли быть компонент обновлен?
    // 
    shouldComponentUpdate(nexrProps){
        // совпадение в условии
        if(this.props.mail.name === nexrProps.mail.name){
            // если да то компонент не должен быть обновлен
            return false
        }else{
            return true
        }
    }
}

// как в функциональном компоненте сравнивать стэйты 
// оборачивать нужный компонент в еще один компонент -> передать стэйт как пропс -> и внутри обернуть в memo()

// Итого
// 1) Функция memo() испоьзуется для функциональных компонентов
// 2) PureComponent / shouldComponentUpdate() - в классовых
// 3) ко всем подряд компонентам применять не стоит а только к тем у кого часто обновляются данные
//! 4) При передече функций в пропсах кmemo() аждый раз будет видеть что это новый пропс
    // чтобы избежать использовать useCallback (т/к занимается мемонизацией функций)

// Для анализа производительности компонентов - инструмент Profiler в браузере